{"entries":[{"timestamp":1754859608730,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":0,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":178,"length1":64,"diffs":[[1,"        \"assets.json\"\n"]]},{"start1":207,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"ns.ts","value":"// google engine\n// adapted from https://github.com/microsoft/pxt-common-packages/blob/master/libs/game/controller.ts https://github.com/microsoft/pxt-common-packages/blob/master/libs/game/prompt.ts\n\n//% block=\"google\" groups=['controller', 'prompt', 'search engine', 'control', 'out of program']\nnamespace google { }"},{"type":"added","filename":"controller.ts","value":"namespace google { \n    let _players: null\n    \n}"}]},{"timestamp":1754860098651,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":218,"length1":77,"diffs":[[1,"        \"controller.ts\"\n"]]}]},{"type":"edited","filename":"controller.ts","patch":[{"start1":0,"length1":975,"diffs":[[1,"namespace google { \n    let _players: null\n    \n}"]]}]},{"type":"added","filename":"control.ts","value":"namespace google.Control {\n    export function deviceDalVersion(): string {\n        return \"0.0.0\";\n        return \"sim\";\n    }\n}"},{"type":"added","filename":"controllerbutton.ts","value":"namespace google.controller { \n    enum ControllerButtonEvent {\n        //% block=\"pressed\"\n        Pressed = KEY_DOWN,\n        //% block=\"released\"\n        Released = KEY_UP,\n        //% block=\"repeat\"\n        Repeated = KEY_REPEAT\n    }\n\n\n    enum ControllerButton {\n        //% block=\"{id:controller}A\"\n        A = 5,\n        //% block=\"{id:controller}B\"\n        B = 6,\n        //% block=\"left\"\n        Left = 1,\n        //% block=\"up\"\n        Up = 2,\n        //% block=\"right\"\n        Right = 3,\n        //% block=\"down\"\n        Down = 4\n    }\n\n    enum ControllerEvent {\n        //% block=\"connected\"\n        Connected = 1,\n        //% block=\"disconnected\"\n        Disconnected = 2\n    }\n\n    /**\n     * Access to game controls\n     */\n    //% weight=98 color=\"#D54322\" icon=\"\\uf11b\"\n    //% groups='[\"Single Player\", \"Multiplayer\"]'\n    //% blockGap=8\n    namespace controller {\n        let _userEventsEnabled = true;\n        let defaultRepeatDelay = 500;\n        let defaultRepeatInterval = 30;\n\n        //% fixedInstances\n        export class Button {\n            _owner: Controller;\n            public id: number;\n            //% help=controller/button/repeat-delay\n            public repeatDelay: number;\n            //% help=controller/button/repeat-interval\n            public repeatInterval: number;\n            private _pressed: boolean;\n            private _pressedElasped: number;\n            private _repeatCount: number;\n            private _buttonId: number;\n\n            toString(): string {\n                return `btn ${this.id} ${this._buttonId} ${this._pressed ? \"down\" : \"up\"}`;\n            }\n\n            constructor(id: number, buttonId: number) {\n                this.id = id;\n                this._buttonId = buttonId;\n                this._pressed = false;\n                this.repeatDelay = undefined;\n                this.repeatInterval = undefined;\n                this._repeatCount = 0;\n                if (id > 0) {\n                    // this is to deal with the \"anyButton\" hack, which creates a button that is not visible\n                    // in the UI, but used in event-handler to simulate the wildcard ANY for matching. As\n                    // this button can't actually be pressed, we don't want it to propagate events\n                    control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => this.setPressed(false), 16)\n                    control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => this.setPressed(true), 16)\n                }\n                if (buttonId > -1) {\n                    // only add these events when running on real hardware\n                    control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_UP, () => control.raiseEvent(INTERNAL_KEY_UP, this.id), 16)\n                    control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_DOWN, () => control.raiseEvent(INTERNAL_KEY_DOWN, this.id), 16)\n                }\n            }\n\n            private raiseButtonUp() {\n                if (_userEventsEnabled)\n                    control.raiseEvent(KEY_UP, this.id)\n                else\n                    control.raiseEvent(SYSTEM_KEY_UP, this.id);\n            }\n\n            private raiseButtonDown() {\n                if (_userEventsEnabled)\n                    control.raiseEvent(KEY_DOWN, this.id)\n                else\n                    control.raiseEvent(SYSTEM_KEY_DOWN, this.id)\n            }\n\n            private raiseButtonRepeat() {\n                if (_userEventsEnabled)\n                    control.raiseEvent(KEY_REPEAT, this.id)\n                else\n                    control.raiseEvent(SYSTEM_KEY_REPEAT, this.id)\n            }\n\n            /**\n             * Run some code when a button is pressed, released, or held\n             */\n            //% weight=99 blockGap=8 help=controller/button/on-event\n            //% blockId=keyonevent block=\"on %button **button** %event\"\n            //% group=\"Single Player\"\n            onEvent(event: ControllerButtonEvent, handler: () => void) {\n                control.onEvent(event, this.id, handler);\n            }\n\n            /**\n             * Pauses until a button is pressed or released\n             */\n            //% weight=98 blockGap=8 help=controller/button/pause-until\n            // blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n            //% group=\"Single Player\"\n            pauseUntil(event: ControllerButtonEvent) {\n                control.waitForEvent(event, this.id)\n            }\n\n            /**\n             * Indicates if the button is currently pressed\n            */\n            //% weight=96 blockGap=8 help=controller/button/is-pressed\n            //% blockId=keyispressed block=\"is %button **button** pressed\"\n            //% group=\"Single Player\"\n            isPressed() {\n                return this._pressed;\n            }\n\n            setPressed(pressed: boolean) {\n                if (this._pressed != pressed) {\n                    power.poke();\n                    if (this._owner)\n                        this._owner.connected = true;\n                    this._pressed = pressed;\n                    if (this._pressed) {\n                        this._pressedElasped = 0;\n                        this.raiseButtonDown();\n                    } else {\n                        this._repeatCount = 0;\n                        this.raiseButtonUp();\n                    }\n                }\n            }\n\n            __update(dtms: number) {\n                if (!this._pressed) return;\n                this._pressedElasped += dtms;\n\n                const delay = this.repeatDelay === undefined ? defaultRepeatDelay : this.repeatDelay;\n                const interval = this.repeatInterval === undefined ? defaultRepeatInterval : this.repeatInterval;\n\n                // inital delay\n                if (this._pressedElasped < delay)\n                    return;\n\n                // repeat count for this step\n                const count = Math.floor((this._pressedElasped - delay - interval) / interval);\n                if (count != this._repeatCount) {\n                    this.raiseButtonRepeat();\n                    this._repeatCount = count;\n                }\n            }\n        }\n\n        class AnyButton extends Button {\n            isPressed(): boolean {\n                const ctrl = player1();\n\n                for (const b of ctrl.buttons) {\n                    if (b.isPressed()) return true;\n                }\n                return false;\n            }\n        }\n\n        /**\n         * Configures the timing of the on button repeat event for all of the controller buttons\n         * @param delay number of milliseconds from when the button is pressed to when the repeat event starts firing, eg: 500\n         * @param interval minimum number of milliseconds between calls to the button repeat event, eg: 30\n         */\n        export function setRepeatDefault(delay: number, interval: number) {\n            defaultRepeatDelay = delay;\n            defaultRepeatInterval = interval;\n        }\n\n        let _players: Controller[];\n\n        function addController(ctrl: Controller) {\n            if (!_players) {\n                _players = [];\n            }\n            _players[ctrl.playerIndex - 1] = ctrl;\n        }\n\n        function player1(): Controller {\n            if (!_players || !_players[0])\n                new Controller(1, [controller.left, controller.up, controller.right, controller.down, controller.A, controller.B, controller.menu]);\n            return _players[0];\n        }\n\n        export function players(): Controller[] {\n            player1(); // ensure player1 is present\n            return _players.filter(ctrl => !!ctrl);\n        }\n\n        export class ControlledSprite {\n            public _inputLastFrame: boolean;\n            constructor(\n                public s: Sprite,\n                public vx: number,\n                public vy: number\n            ) { }\n        }\n\n        export function _moveSprites() {\n            // todo: move to currecnt sceane\n            control.enablePerfCounter(\"controller\")\n            players().forEach(ctrl => ctrl.__preUpdate());\n        }\n\n        //% fixedInstances\n        export class Controller {\n            playerIndex: number;\n            buttons: Button[];\n            private _id: number;\n            private _connected: boolean;\n\n            // array of left,up,right,down,a,b,menu buttons\n            constructor(playerIndex: number, buttons: Button[]) {\n                this._id = control.allocateNotifyEvent();\n                this._connected = false;\n                this.playerIndex = playerIndex;\n                if (buttons)\n                    this.buttons = buttons;\n                else {\n                    this.buttons = [];\n                    const leftId = 1 + (this.playerIndex - 1) * 7;\n                    for (let i = 0; i < 7; ++i) {\n                        this.buttons.push(new Button(leftId + i, -1));\n                    }\n                }\n                for (let i = 0; i < this.buttons.length; ++i)\n                    this.buttons[i]._owner = this;\n                addController(this);\n            }\n\n            get _controlledSprites(): ControlledSprite[] {\n                return game.currentScene().controlledSprites[this.playerIndex];\n            }\n\n            set _controlledSprites(cps: ControlledSprite[]) {\n                game.currentScene().controlledSprites[this.playerIndex] = cps;\n            }\n\n            get id() {\n                return this._id;\n            }\n\n            dump() {\n                this.buttons.forEach(b => console.log(b.toString()));\n            }\n\n            /**\n             * Gets the left button\n             */\n            //%\n            get left() {\n                return this.button(ControllerButton.Left);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get right() {\n                return this.button(ControllerButton.Right);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get up() {\n                return this.button(ControllerButton.Up);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get down() {\n                return this.button(ControllerButton.Down);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get A() {\n                return this.button(ControllerButton.A);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get B() {\n                return this.button(ControllerButton.B);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get menu() {\n                return this.button(7);\n            }\n\n            /**\n             * Control a sprite using the direction buttons from the controller. Note that this will overwrite\n             * the current velocity of the sprite whenever a directional button is pressed. To stop controlling\n             * a sprite, pass 0 for vx and vy.\n             *\n             * @param sprite The Sprite to control\n             * @param vx The velocity used for horizontal movement when left/right is pressed\n             * @param vy The velocity used for vertical movement when up/down is pressed\n             */\n            //% blockId=\"ctrlgame_control_sprite\" block=\"%controller move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n            //% weight=100\n            //% expandableArgumentMode=\"toggle\"\n            //% vx.defl=100 vy.defl=100\n            //% help=controller/move-sprite\n            //% group=\"Multiplayer\"\n            moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n                if (!sprite) return;\n                if (!this._controlledSprites) this._controlledSprites = [];\n                let cp = this._controlledSprites.find(cp => cp.s.id == sprite.id);\n                if (!cp) {\n                    cp = new ControlledSprite(sprite, vx, vy);\n                    this._controlledSprites.push(cp);\n                }\n                if (cp.vx && vx == 0) {\n                    cp.s.vx = 0\n                }\n                if (cp.vy && vy == 0) {\n                    cp.s.vy = 0\n                }\n                cp.vx = vx;\n                cp.vy = vy;\n            }\n\n            private button(button: ControllerButton): Button {\n                return this.buttons[button - 1];\n            }\n\n            /**\n             * Run some code when a button is pressed, released, or held\n             */\n            //% weight=99 blockGap=8\n            //% blockId=ctrlonbuttonevent block=\"on %controller %button **button** %event\"\n            //% group=\"Multiplayer\"\n            //% help=controller/on-button-event\n            onButtonEvent(btn: ControllerButton, event: ControllerButtonEvent, handler: () => void) {\n                this.button(btn).onEvent(event, handler);\n            }\n\n            /**\n             * Register code run when a controller event occurs\n             * @param event\n             * @param handler\n             */\n            //% weight=99 blockGap=8\n            //% blockId=ctrlonevent block=\"on %controller %event\"\n            //% group=\"Multiplayer\"\n            //% help=controller/on-event\n            onEvent(event: ControllerEvent, handler: () => void) {\n                control.onEvent(this.id, event, handler);\n            }\n\n            get connected() {\n                return this._connected;\n            }\n\n            set connected(value: boolean) {\n                if (value != this._connected) {\n                    this._connected = value;\n                    control.raiseEvent(this.id, this._connected ? ControllerEvent.Connected : ControllerEvent.Disconnected);\n                }\n            }\n\n            /**\n             * Indicates if the button is currently pressed\n            */\n            //% weight=96 blockGap=8 help=controller/button/is-pressed\n            //% blockId=ctrlispressed block=\"is %controller %button **button** pressed\"\n            //% group=\"Multiplayer\"\n            isPressed(btn: ControllerButton): boolean {\n                return this.button(btn).isPressed();\n            }\n\n            /**\n             * Get the horizontal movement, given the step and state of buttons\n             * @param step the distance, eg: 100\n             */\n            //% weight=50 blockGap=8 help=controller/dx\n            //% blockId=ctrldx block=\"%controller dx (left-right buttons)||scaled by %step\"\n            //% step.defl=100\n            //% group=\"Multiplayer\"\n            dx(step: number = 100) {\n                const ctx = control.eventContext();\n                if (!ctx) return 0;\n\n                if (this.left.isPressed()) {\n                    if (this.right.isPressed()) return 0\n                    else return -step * ctx.deltaTime;\n                }\n                else if (this.right.isPressed()) return step * ctx.deltaTime\n                else return 0\n            }\n\n            /**\n             * Get the vertical movement, given the step and state of buttons\n             * @param step the distance, eg: 100\n             */\n            //% weight=49 help=keys/dy\n            //% blockId=ctrldy block=\"%controller dy (up-down buttons)||scaled by %step\"\n            //% step.defl=100\n            //% group=\"Multiplayer\"\n            dy(step: number = 100) {\n                const ctx = control.eventContext();\n                if (!ctx) return 0;\n\n                if (this.up.isPressed()) {\n                    if (this.down.isPressed()) return 0\n                    else return -step * ctx.deltaTime;\n                }\n                else if (this.down.isPressed()) return step * ctx.deltaTime\n                else return 0\n            }\n\n            __preUpdate() {\n                if (!this._controlledSprites) return;\n\n                let deadSprites = false;\n                const corner = Fx.rightShift(Fx8(Math.SQRT2), 1);\n                const side = Fx8(1);\n                this._controlledSprites.forEach(controlledSprite => {\n                    const { s, vx, vy } = controlledSprite;\n                    if (s.flags & sprites.Flag.Destroyed) {\n                        deadSprites = true;\n                        return;\n                    }\n\n                    let svx = 0;\n                    let svy = 0;\n\n                    if (vx) {\n                        if (this.right.isPressed())\n                            svx += vx;\n                        if (this.left.isPressed())\n                            svx -= vx;\n                    }\n\n                    if (vy) {\n                        if (this.down.isPressed())\n                            svy += vy;\n                        if (this.up.isPressed())\n                            svy -= vy;\n                    }\n\n                    if (controlledSprite._inputLastFrame) {\n                        if (vx) s.vx = 0;\n                        if (vy) s.vy = 0;\n                    }\n\n                    if (svx || svy) {\n                        if (vx && vy) {\n                            s._vx = Fx.mul(\n                                Fx8(svx),\n                                svy ? corner : side\n                            );\n                            s._vy = Fx.mul(\n                                Fx8(svy),\n                                svx ? corner : side\n                            );\n                        } else if (vx) {\n                            s.vx = svx;\n                        } else if (vy) {\n                            s.vy = svy;\n                        }\n\n                        controlledSprite._inputLastFrame = true;\n                    }\n                    else {\n                        controlledSprite._inputLastFrame = false;\n                    }\n                });\n\n                if (deadSprites)\n                    this._controlledSprites = this._controlledSprites\n                        .filter(s => !(s.s.flags & sprites.Flag.Destroyed));\n            }\n\n            __update(dtms: number) {\n                dtms = dtms | 0;\n                this.buttons.forEach(btn => btn.__update(dtms));\n            }\n\n            serialize(offset: number): Buffer {\n                const buf = control.createBuffer(offset + 1);\n                let b = 0;\n                for (let i = 0; this.buttons.length; ++i)\n                    b |= (this.buttons[i].isPressed() ? 1 : 0) << i;\n                buf[offset] = b\n                return buf;\n            }\n        }\n\n        /**\n         * Called by the game engine to update and/or raise events\n         */\n        export function __update(dt: number) {\n            const dtms = (dt * 1000) | 0\n            players().forEach(ctrl => ctrl.__update(dtms));\n        }\n\n        export function serialize(offset: number): Buffer {\n            return player1().serialize(offset);\n        }\n\n        /**\n         * Control a sprite using the direction buttons from the controller. Note that this\n         * control will take over the vx and vy of the sprite and overwrite any changes\n         * made unless a 0 is passed.\n         *\n         * @param sprite The Sprite to control\n         * @param vx The velocity used for horizontal movement when left/right is pressed\n         * @param vy The velocity used for vertical movement when up/down is pressed\n         */\n        //% blockId=\"game_control_sprite\" block=\"move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n        //% weight=100\n        //% expandableArgumentMode=\"toggle\"\n        //% vx.defl=100 vy.defl=100\n        //% help=controller/move-sprite\n        //% group=\"Single Player\"\n        export function moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n            player1().moveSprite(sprite, vx, vy);\n        }\n\n\n        /**\n         * Pause the program until a button is pressed\n         */\n        //% weight=10\n        export function pauseUntilAnyButtonIsPressed() {\n            control.waitForEvent(KEY_DOWN, 0)\n        }\n\n        export function _setUserEventsEnabled(enabled: boolean) {\n            _userEventsEnabled = enabled;\n        }\n\n        /**\n         * Get the horizontal movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=50 blockGap=8 help=controller/dx\n        //% blockId=keydx block=\"dx (left-right buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Single Player\"\n        export function dx(step: number = 100) {\n            return player1().dx(step);\n        }\n\n        /**\n         * Get the vertical movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=49 help=keys/dy\n        //% blockId=keydy block=\"dy (up-down buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Single Player\"\n        export function dy(step: number = 100) {\n            return player1().dy(step);\n        }\n\n\n        //% fixedInstance block=\"any\"\n        export const anyButton: Button = new AnyButton(0, -1);\n    }\n}"}]},{"timestamp":1754860685327,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":265,"length1":63,"diffs":[[1,"        \"controllerbutton.ts\"\n"]]}]},{"type":"edited","filename":"controllerbutton.ts","patch":[{"start1":31,"length1":45,"diffs":[[1,"    enum ControllerButtonEvent {\n"]]},{"start1":241,"length1":34,"diffs":[[1,"    enum ControllerButton {\n"]]},{"start1":549,"length1":33,"diffs":[[1,"    enum ControllerEvent {\n"]]},{"start1":694,"length1":0,"diffs":[[1,"    /**\n     * Access to game controls\n     */\n    //% weight=98 color=\"#D54322\" icon=\"\\uf11b\"\n    //% groups='[\"Single Player\", \"Multiplayer\"]'\n    //% blockGap=8\n    namespace controller {\n"]]},{"start1":18987,"length1":0,"diffs":[[1,"        /**\n         * Control a sprite using the direction buttons from the controller. Note that this\n         * control will take over the vx and vy of the sprite and overwrite any changes\n         * made unless a 0 is passed.\n         *\n         * @param sprite The Sprite to control\n         * @param vx The velocity used for horizontal movement when left/right is pressed\n         * @param vy The velocity used for vertical movement when up/down is pressed\n         */\n        //% blockId=\"game_control_sprite\" block=\"move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n        //% weight=100\n        //% expandableArgumentMode=\"toggle\"\n        //% vx.defl=100 vy.defl=100\n        //% help=controller/move-sprite\n        //% group=\"Single Player\"\n        export function moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n            player1().moveSprite(sprite, vx, vy);\n        }\n"]]},{"start1":19904,"length1":0,"diffs":[[1,"\n"]]},{"start1":20239,"length1":0,"diffs":[[1,"        /**\n         * Get the horizontal movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=50 blockGap=8 help=controller/dx\n        //% blockId=keydx block=\"dx (left-right buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Single Player\"\n        export function dx(step: number = 100) {\n            return player1().dx(step);\n        }\n"]]},{"start1":20670,"length1":0,"diffs":[[1,"        /**\n         * Get the vertical movement, given the step and state of buttons\n         * @param step the distance, eg: 100\n         */\n        //% weight=49 help=keys/dy\n        //% blockId=keydy block=\"dy (up-down buttons)||scaled by %step\"\n        //% step.defl=100\n        //% group=\"Single Player\"\n        export function dy(step: number = 100) {\n            return player1().dy(step);\n        }\n\n\n"]]},{"start1":21187,"length1":1,"diffs":[[1,"}"]]}]},{"type":"added","filename":"controlleroverides.ts","value":"namespace google.controller{\r\n    //% fixedInstance whenUsed block=\"{id:controller}A\"\r\n    export const A = new Button(ControllerButton.A, DAL.CFG_PIN_BTN_A);\r\n    //% fixedInstance whenUsed block=\"{id:controller}B\"\r\n    export const B = new Button(ControllerButton.B, DAL.CFG_PIN_BTN_B);\r\n    //% fixedInstance whenUsed block=\"left\"\r\n    export const left = new Button(ControllerButton.Left, DAL.CFG_PIN_BTN_LEFT);\r\n    //% fixedInstance whenUsed block=\"up\"\r\n    export const up = new Button(ControllerButton.Up, DAL.CFG_PIN_BTN_UP);\r\n    //% fixedInstance whenUsed block=\"right\"\r\n    export const right = new Button(ControllerButton.Right, DAL.CFG_PIN_BTN_RIGHT);\r\n    //% fixedInstance whenUsed block=\"down\"\r\n    export const down = new Button(ControllerButton.Down, DAL.CFG_PIN_BTN_DOWN);\r\n    //% fixedInstance whenUsed block=\"menu\"\r\n    export const menu = new Button(7, DAL.CFG_PIN_BTN_MENU);\r\n\r\n    //% fixedInstance whenUsed block=\"player 2\"\r\n    export const player2 = new Controller(2, undefined);\r\n    //% fixedInstance whenUsed block=\"player 3\"\r\n    export const player3 = new Controller(3, undefined);\r\n    //% fixedInstance whenUsed block=\"player 4\"\r\n    export const player4 = new Controller(4, undefined);\r\n    //% fixedInstance whenUsed block=\"player 1\"\r\n    export const player1 = new Controller(1, undefined)\r\n}"}]},{"timestamp":1754861307423,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":296,"length1":65,"diffs":[[1,"        \"controlleroverides.ts\"\n"]]}]},{"type":"added","filename":"searchEnginePrompt.ts","value":""}]},{"timestamp":1754861314530,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":22,"diffs":[[1,"    \"name\": \"OneStart\",\n"]]}]},{"type":"edited","filename":"controllerbutton.ts","patch":[{"start1":31,"length1":35,"diffs":[[1,"   export enum GoogleControllerButtonEvent {\n"]]},{"start1":253,"length1":79,"diffs":[[1,"    enum GoogleControllerButton {\n        //% block=\"{id:controller}A\"\n"]]},{"start1":339,"length1":33,"diffs":[[1,"        //% block=\"{id:controller}B\"\n"]]},{"start1":3638,"length1":78,"diffs":[[1,"            //% blockId=keyonevent block=\"on %button **button** %event\"\n"]]},{"start1":3748,"length1":73,"diffs":[[1,"            onEvent(event: ControllerButtonEvent, handler: () => void) {\n"]]},{"start1":4058,"length1":92,"diffs":[[1,"            // blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n"]]},{"start1":4182,"length1":51,"diffs":[[1,"            pauseUntil(event: ControllerButtonEvent) {\n"]]},{"start1":4467,"length1":81,"diffs":[[1,"            //% blockId=keyispressed block=\"is %button **button** pressed\"\n"]]},{"start1":9550,"length1":65,"diffs":[[1,"                return this.button(ControllerButton.Left);\n"]]},{"start1":9735,"length1":66,"diffs":[[1,"                return this.button(ControllerButton.Right);\n"]]},{"start1":9918,"length1":63,"diffs":[[1,"                return this.button(ControllerButton.Up);\n"]]},{"start1":10100,"length1":65,"diffs":[[1,"                return this.button(ControllerButton.Down);\n"]]},{"start1":10281,"length1":62,"diffs":[[1,"                return this.button(ControllerButton.A);\n"]]},{"start1":10459,"length1":62,"diffs":[[1,"                return this.button(ControllerButton.B);\n"]]},{"start1":11245,"length1":142,"diffs":[[1,"            //% blockId=\"ctrlgame_control_sprite\" block=\"%controller move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n"]]},{"start1":12261,"length1":75,"diffs":[[1,"            private button(button: ControllerButton): Button {\n"]]},{"start1":12705,"length1":108,"diffs":[[1,"            onButtonEvent(btn: ControllerButton, event: ControllerButtonEvent, handler: () => void) {\n"]]},{"start1":13214,"length1":73,"diffs":[[1,"            onEvent(event: ControllerEvent, handler: () => void) {\n"]]},{"start1":13896,"length1":94,"diffs":[[1,"            //% blockId=ctrlispressed block=\"is %controller %button **button** pressed\"\n"]]},{"start1":14020,"length1":68,"diffs":[[1,"            isPressed(btn: ControllerButton): boolean {\n"]]}]},{"type":"edited","filename":"searchEnginePrompt.ts","patch":[{"start1":0,"length1":17926,"diffs":[[1,""]]}]}]},{"timestamp":1754861912048,"editorVersion":"2.0.56","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":157,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":366,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"controllerbutton.ts","patch":[{"start1":243,"length1":41,"diffs":[[1,"   export enum GoogleGoogleControllerButton {\n"]]},{"start1":12312,"length1":69,"diffs":[[1,"            private button(button: GoogleGoogleControllerButton): Button {\n"]]},{"start1":12593,"length1":97,"diffs":[[1,"            //% blockId=ctrlonbuttonevent block=\"on %controller %button **button** %event\"\n"]]},{"start1":13140,"length1":72,"diffs":[[1,"            //% blockId=ctrlonevent block=\"on %controller %event\"\n"]]},{"start1":14101,"length1":62,"diffs":[[1,"            isPressed(btn: GoogleGoogleControllerButton): boolean {\n"]]},{"start1":14454,"length1":98,"diffs":[[1,"            //% blockId=ctrldx block=\"%controller dx (left-right buttons)||scaled by %step\"\n"]]},{"start1":15035,"length1":0,"diffs":[[1,"            /**\n             * Get the vertical movement, given the step and state of buttons\n             * @param step the distance, eg: 100\n             */\n            //% weight=49 help=keys/dy\n            //% blockId=ctrldy block=\"%controller dy (up-down buttons)||scaled by %step\"\n            //% step.defl=100\n            //% group=\"Multiplayer\"\n            dy(step: number = 100) {\n                const ctx = control.eventContext();\n                if (!ctx) return 0;\n\n                if (this.up.isPressed()) {\n                    if (this.down.isPressed()) return 0\n                    else return -step * ctx.deltaTime;\n                }\n                else if (this.down.isPressed()) return step * ctx.deltaTime\n                else return 0\n            }\n\n"]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1754859608729,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"OneStart\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1754861412262,"editorVersion":"2.0.56","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"","README.md":" ","assets.json":"","ns.ts":"// google engine\n// adapted from https://github.com/microsoft/pxt-common-packages/blob/master/libs/game/controller.ts https://github.com/microsoft/pxt-common-packages/blob/master/libs/game/prompt.ts\n\n//% block=\"google\" groups=['controller', 'prompt', 'search engine', 'control', 'out of program']\nnamespace google { }","controller.ts":"namespace google.controller { \n   export let _players: controller.Controller[]\n\n    game.addScenePopHandler(() => {\n        const stateWhenPushed = game.currentScene().controllerConnectionState;\n        if (!stateWhenPushed)\n            return;\n        for (let i = 0; i < stateWhenPushed.length; i++) {\n            const p = _players[i];\n            if (p && (!!stateWhenPushed[i] != !!p.connected)) {\n                // connection state changed while in another scene; raise the event.\n                control.raiseEvent(\n                    p.id,\n                    p.connected ? ControllerEvent.Connected : ControllerEvent.Disconnected\n                );\n            }\n        }\n\n    })\n    game.addScenePushHandler(oldScene => {\n        oldScene.controllerConnectionState = [];\n        for (let i = 0; i < _players.length; i++) {\n            if (_players[i]) {\n                oldScene.controllerConnectionState[i] = _players[i].connected;\n            }\n        }\n})}\n\n","control.ts":"namespace google.Control {\n    export function deviceDalVersion(): string {\n        return \"0.0.0\";\n        return \"sim\";\n    }\n}","controllerbutton.ts":"namespace google.controller { \n   export enum GoogleControllerButtonEvent {\n        //% block=\"pressed\"\n        Pressed = KEY_DOWN,\n        //% block=\"released\"\n        Released = KEY_UP,\n        //% block=\"repeat\"\n        Repeated = KEY_REPEAT\n    }\n\n\n    enum GoogleControllerButton {\n        //% block=\"{id:controller}A\"\n        A = 5,\n        //% block=\"{id:controller}B\"\n        B = 6,\n        //% block=\"left\"\n        Left = 1,\n        //% block=\"up\"\n        Up = 2,\n        //% block=\"right\"\n        Right = 3,\n        //% block=\"down\"\n        Down = 4\n    }\n\n    enum GoogleControllerEvent {\n        //% block=\"connected\"\n        Connected = 1,\n        //% block=\"disconnected\"\n        Disconnected = 2\n    }\n\n        let _userEventsEnabled = true;\n        let defaultRepeatDelay = 500;\n        let defaultRepeatInterval = 30;\n\n        //% fixedInstances\n        export class Button {\n            _owner: Controller;\n            public id: number;\n            //% help=controller/button/repeat-delay\n            public repeatDelay: number;\n            //% help=controller/button/repeat-interval\n            public repeatInterval: number;\n            private _pressed: boolean;\n            private _pressedElasped: number;\n            private _repeatCount: number;\n            private _buttonId: number;\n\n            toString(): string {\n                return `btn ${this.id} ${this._buttonId} ${this._pressed ? \"down\" : \"up\"}`;\n            }\n\n            constructor(id: number, buttonId: number) {\n                this.id = id;\n                this._buttonId = buttonId;\n                this._pressed = false;\n                this.repeatDelay = undefined;\n                this.repeatInterval = undefined;\n                this._repeatCount = 0;\n                if (id > 0) {\n                    // this is to deal with the \"anyButton\" hack, which creates a button that is not visible\n                    // in the UI, but used in event-handler to simulate the wildcard ANY for matching. As\n                    // this button can't actually be pressed, we don't want it to propagate events\n                    control.internalOnEvent(INTERNAL_KEY_UP, this.id, () => this.setPressed(false), 16)\n                    control.internalOnEvent(INTERNAL_KEY_DOWN, this.id, () => this.setPressed(true), 16)\n                }\n                if (buttonId > -1) {\n                    // only add these events when running on real hardware\n                    control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_UP, () => control.raiseEvent(INTERNAL_KEY_UP, this.id), 16)\n                    control.internalOnEvent(buttonId, DAL.DEVICE_BUTTON_EVT_DOWN, () => control.raiseEvent(INTERNAL_KEY_DOWN, this.id), 16)\n                }\n            }\n\n            private raiseButtonUp() {\n                if (_userEventsEnabled)\n                    control.raiseEvent(KEY_UP, this.id)\n                else\n                    control.raiseEvent(SYSTEM_KEY_UP, this.id);\n            }\n\n            private raiseButtonDown() {\n                if (_userEventsEnabled)\n                    control.raiseEvent(KEY_DOWN, this.id)\n                else\n                    control.raiseEvent(SYSTEM_KEY_DOWN, this.id)\n            }\n\n            private raiseButtonRepeat() {\n                if (_userEventsEnabled)\n                    control.raiseEvent(KEY_REPEAT, this.id)\n                else\n                    control.raiseEvent(SYSTEM_KEY_REPEAT, this.id)\n            }\n\n            /**\n             * Run some code when a button is pressed, released, or held\n             */\n            //% weight=99 blockGap=8 help=controller/button/on-event\n            //% blockId=keyonevent block=\"on %button **button** %event\"\n            //% group=\"Single Player\"\n            onEvent(event: ControllerButtonEvent, handler: () => void) {\n                control.onEvent(event, this.id, handler);\n            }\n\n            /**\n             * Pauses until a button is pressed or released\n             */\n            //% weight=98 blockGap=8 help=controller/button/pause-until\n            // blockId=keypauseuntil block=\"pause until %button **button** is %event\"\n            //% group=\"Single Player\"\n            pauseUntil(event: ControllerButtonEvent) {\n                control.waitForEvent(event, this.id)\n            }\n\n            /**\n             * Indicates if the button is currently pressed\n            */\n            //% weight=96 blockGap=8 help=controller/button/is-pressed\n            //% blockId=keyispressed block=\"is %button **button** pressed\"\n            //% group=\"Single Player\"\n            isPressed() {\n                return this._pressed;\n            }\n\n            setPressed(pressed: boolean) {\n                if (this._pressed != pressed) {\n                    power.poke();\n                    if (this._owner)\n                        this._owner.connected = true;\n                    this._pressed = pressed;\n                    if (this._pressed) {\n                        this._pressedElasped = 0;\n                        this.raiseButtonDown();\n                    } else {\n                        this._repeatCount = 0;\n                        this.raiseButtonUp();\n                    }\n                }\n            }\n\n            __update(dtms: number) {\n                if (!this._pressed) return;\n                this._pressedElasped += dtms;\n\n                const delay = this.repeatDelay === undefined ? defaultRepeatDelay : this.repeatDelay;\n                const interval = this.repeatInterval === undefined ? defaultRepeatInterval : this.repeatInterval;\n\n                // inital delay\n                if (this._pressedElasped < delay)\n                    return;\n\n                // repeat count for this step\n                const count = Math.floor((this._pressedElasped - delay - interval) / interval);\n                if (count != this._repeatCount) {\n                    this.raiseButtonRepeat();\n                    this._repeatCount = count;\n                }\n            }\n        }\n\n        class AnyButton extends Button {\n            isPressed(): boolean {\n                const ctrl = player1();\n\n                for (const b of ctrl.buttons) {\n                    if (b.isPressed()) return true;\n                }\n                return false;\n            }\n        }\n\n        /**\n         * Configures the timing of the on button repeat event for all of the controller buttons\n         * @param delay number of milliseconds from when the button is pressed to when the repeat event starts firing, eg: 500\n         * @param interval minimum number of milliseconds between calls to the button repeat event, eg: 30\n         */\n        export function setRepeatDefault(delay: number, interval: number) {\n            defaultRepeatDelay = delay;\n            defaultRepeatInterval = interval;\n        }\n\n        let _players: Controller[];\n\n        function addController(ctrl: Controller) {\n            if (!_players) {\n                _players = [];\n            }\n            _players[ctrl.playerIndex - 1] = ctrl;\n        }\n\n        function player1(): Controller {\n            if (!_players || !_players[0])\n                new Controller(1, [controller.left, controller.up, controller.right, controller.down, controller.A, controller.B, controller.menu]);\n            return _players[0];\n        }\n\n        export function players(): Controller[] {\n            player1(); // ensure player1 is present\n            return _players.filter(ctrl => !!ctrl);\n        }\n\n        export class ControlledSprite {\n            public _inputLastFrame: boolean;\n            constructor(\n                public s: Sprite,\n                public vx: number,\n                public vy: number\n            ) { }\n        }\n\n        export function _moveSprites() {\n            // todo: move to currecnt sceane\n            control.enablePerfCounter(\"controller\")\n            players().forEach(ctrl => ctrl.__preUpdate());\n        }\n\n        //% fixedInstances\n        export class Controller {\n            playerIndex: number;\n            buttons: Button[];\n            private _id: number;\n            private _connected: boolean;\n\n            // array of left,up,right,down,a,b,menu buttons\n            constructor(playerIndex: number, buttons: Button[]) {\n                this._id = control.allocateNotifyEvent();\n                this._connected = false;\n                this.playerIndex = playerIndex;\n                if (buttons)\n                    this.buttons = buttons;\n                else {\n                    this.buttons = [];\n                    const leftId = 1 + (this.playerIndex - 1) * 7;\n                    for (let i = 0; i < 7; ++i) {\n                        this.buttons.push(new Button(leftId + i, -1));\n                    }\n                }\n                for (let i = 0; i < this.buttons.length; ++i)\n                    this.buttons[i]._owner = this;\n                addController(this);\n            }\n\n            get _controlledSprites(): ControlledSprite[] {\n                return game.currentScene().controlledSprites[this.playerIndex];\n            }\n\n            set _controlledSprites(cps: ControlledSprite[]) {\n                game.currentScene().controlledSprites[this.playerIndex] = cps;\n            }\n\n            get id() {\n                return this._id;\n            }\n\n            dump() {\n                this.buttons.forEach(b => console.log(b.toString()));\n            }\n\n            /**\n             * Gets the left button\n             */\n            //%\n            get left() {\n                return this.button(ControllerButton.Left);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get right() {\n                return this.button(ControllerButton.Right);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get up() {\n                return this.button(ControllerButton.Up);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get down() {\n                return this.button(ControllerButton.Down);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get A() {\n                return this.button(ControllerButton.A);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get B() {\n                return this.button(ControllerButton.B);\n            }\n\n            /**\n             * Gets the right button\n             */\n            //%\n            get menu() {\n                return this.button(7);\n            }\n\n            /**\n             * Control a sprite using the direction buttons from the controller. Note that this will overwrite\n             * the current velocity of the sprite whenever a directional button is pressed. To stop controlling\n             * a sprite, pass 0 for vx and vy.\n             *\n             * @param sprite The Sprite to control\n             * @param vx The velocity used for horizontal movement when left/right is pressed\n             * @param vy The velocity used for vertical movement when up/down is pressed\n             */\n            //% blockId=\"ctrlgame_control_sprite\" block=\"%controller move $sprite=variables_get(mySprite) with buttons||vx $vx vy $vy\"\n            //% weight=100\n            //% expandableArgumentMode=\"toggle\"\n            //% vx.defl=100 vy.defl=100\n            //% help=controller/move-sprite\n            //% group=\"Multiplayer\"\n            moveSprite(sprite: Sprite, vx: number = 100, vy: number = 100) {\n                if (!sprite) return;\n                if (!this._controlledSprites) this._controlledSprites = [];\n                let cp = this._controlledSprites.find(cp => cp.s.id == sprite.id);\n                if (!cp) {\n                    cp = new ControlledSprite(sprite, vx, vy);\n                    this._controlledSprites.push(cp);\n                }\n                if (cp.vx && vx == 0) {\n                    cp.s.vx = 0\n                }\n                if (cp.vy && vy == 0) {\n                    cp.s.vy = 0\n                }\n                cp.vx = vx;\n                cp.vy = vy;\n            }\n\n            private button(button: ControllerButton): Button {\n                return this.buttons[button - 1];\n            }\n\n            /**\n             * Run some code when a button is pressed, released, or held\n             */\n            //% weight=99 blockGap=8\n            //% blockId=ctrlonbuttonevent block=\"on %controller %button **button** %event\"\n            //% group=\"Multiplayer\"\n            //% help=controller/on-button-event\n            onButtonEvent(btn: ControllerButton, event: ControllerButtonEvent, handler: () => void) {\n                this.button(btn).onEvent(event, handler);\n            }\n\n            /**\n             * Register code run when a controller event occurs\n             * @param event\n             * @param handler\n             */\n            //% weight=99 blockGap=8\n            //% blockId=ctrlonevent block=\"on %controller %event\"\n            //% group=\"Multiplayer\"\n            //% help=controller/on-event\n            onEvent(event: ControllerEvent, handler: () => void) {\n                control.onEvent(this.id, event, handler);\n            }\n\n            get connected() {\n                return this._connected;\n            }\n\n            set connected(value: boolean) {\n                if (value != this._connected) {\n                    this._connected = value;\n                    control.raiseEvent(this.id, this._connected ? ControllerEvent.Connected : ControllerEvent.Disconnected);\n                }\n            }\n\n            /**\n             * Indicates if the button is currently pressed\n            */\n            //% weight=96 blockGap=8 help=controller/button/is-pressed\n            //% blockId=ctrlispressed block=\"is %controller %button **button** pressed\"\n            //% group=\"Multiplayer\"\n            isPressed(btn: ControllerButton): boolean {\n                return this.button(btn).isPressed();\n            }\n\n            /**\n             * Get the horizontal movement, given the step and state of buttons\n             * @param step the distance, eg: 100\n             */\n            //% weight=50 blockGap=8 help=controller/dx\n            //% blockId=ctrldx block=\"%controller dx (left-right buttons)||scaled by %step\"\n            //% step.defl=100\n            //% group=\"Multiplayer\"\n            dx(step: number = 100) {\n                const ctx = control.eventContext();\n                if (!ctx) return 0;\n\n                if (this.left.isPressed()) {\n                    if (this.right.isPressed()) return 0\n                    else return -step * ctx.deltaTime;\n                }\n                else if (this.right.isPressed()) return step * ctx.deltaTime\n                else return 0\n            }\n\n            /**\n             * Get the vertical movement, given the step and state of buttons\n             * @param step the distance, eg: 100\n             */\n            //% weight=49 help=keys/dy\n            //% blockId=ctrldy block=\"%controller dy (up-down buttons)||scaled by %step\"\n            //% step.defl=100\n            //% group=\"Multiplayer\"\n            dy(step: number = 100) {\n                const ctx = control.eventContext();\n                if (!ctx) return 0;\n\n                if (this.up.isPressed()) {\n                    if (this.down.isPressed()) return 0\n                    else return -step * ctx.deltaTime;\n                }\n                else if (this.down.isPressed()) return step * ctx.deltaTime\n                else return 0\n            }\n\n            __preUpdate() {\n                if (!this._controlledSprites) return;\n\n                let deadSprites = false;\n                const corner = Fx.rightShift(Fx8(Math.SQRT2), 1);\n                const side = Fx8(1);\n                this._controlledSprites.forEach(controlledSprite => {\n                    const { s, vx, vy } = controlledSprite;\n                    if (s.flags & sprites.Flag.Destroyed) {\n                        deadSprites = true;\n                        return;\n                    }\n\n                    let svx = 0;\n                    let svy = 0;\n\n                    if (vx) {\n                        if (this.right.isPressed())\n                            svx += vx;\n                        if (this.left.isPressed())\n                            svx -= vx;\n                    }\n\n                    if (vy) {\n                        if (this.down.isPressed())\n                            svy += vy;\n                        if (this.up.isPressed())\n                            svy -= vy;\n                    }\n\n                    if (controlledSprite._inputLastFrame) {\n                        if (vx) s.vx = 0;\n                        if (vy) s.vy = 0;\n                    }\n\n                    if (svx || svy) {\n                        if (vx && vy) {\n                            s._vx = Fx.mul(\n                                Fx8(svx),\n                                svy ? corner : side\n                            );\n                            s._vy = Fx.mul(\n                                Fx8(svy),\n                                svx ? corner : side\n                            );\n                        } else if (vx) {\n                            s.vx = svx;\n                        } else if (vy) {\n                            s.vy = svy;\n                        }\n\n                        controlledSprite._inputLastFrame = true;\n                    }\n                    else {\n                        controlledSprite._inputLastFrame = false;\n                    }\n                });\n\n                if (deadSprites)\n                    this._controlledSprites = this._controlledSprites\n                        .filter(s => !(s.s.flags & sprites.Flag.Destroyed));\n            }\n\n            __update(dtms: number) {\n                dtms = dtms | 0;\n                this.buttons.forEach(btn => btn.__update(dtms));\n            }\n\n            serialize(offset: number): Buffer {\n                const buf = control.createBuffer(offset + 1);\n                let b = 0;\n                for (let i = 0; this.buttons.length; ++i)\n                    b |= (this.buttons[i].isPressed() ? 1 : 0) << i;\n                buf[offset] = b\n                return buf;\n            }\n        }\n\n        /**\n         * Called by the game engine to update and/or raise events\n         */\n        export function __update(dt: number) {\n            const dtms = (dt * 1000) | 0\n            players().forEach(ctrl => ctrl.__update(dtms));\n        }\n\n        export function serialize(offset: number): Buffer {\n            return player1().serialize(offset);\n        }\n\n\n        /**\n         * Pause the program until a button is pressed\n         */\n        //% weight=10\n        export function pauseUntilAnyButtonIsPressed() {\n            control.waitForEvent(KEY_DOWN, 0)\n        }\n\n        export function _setUserEventsEnabled(enabled: boolean) {\n            _userEventsEnabled = enabled;\n        }\n\n\n        //% fixedInstance block=\"any\"\n        export const anyButton: Button = new AnyButton(0, -1);\n    }\n\n","controlleroverides.ts":"namespace google.controller{\r\n    //% fixedInstance whenUsed block=\"{id:controller}A\"\r\n    export const A = new Button(ControllerButton.A, DAL.CFG_PIN_BTN_A);\r\n    //% fixedInstance whenUsed block=\"{id:controller}B\"\r\n    export const B = new Button(ControllerButton.B, DAL.CFG_PIN_BTN_B);\r\n    //% fixedInstance whenUsed block=\"left\"\r\n    export const left = new Button(ControllerButton.Left, DAL.CFG_PIN_BTN_LEFT);\r\n    //% fixedInstance whenUsed block=\"up\"\r\n    export const up = new Button(ControllerButton.Up, DAL.CFG_PIN_BTN_UP);\r\n    //% fixedInstance whenUsed block=\"right\"\r\n    export const right = new Button(ControllerButton.Right, DAL.CFG_PIN_BTN_RIGHT);\r\n    //% fixedInstance whenUsed block=\"down\"\r\n    export const down = new Button(ControllerButton.Down, DAL.CFG_PIN_BTN_DOWN);\r\n    //% fixedInstance whenUsed block=\"menu\"\r\n    export const menu = new Button(7, DAL.CFG_PIN_BTN_MENU);\r\n\r\n    //% fixedInstance whenUsed block=\"player 2\"\r\n    export const player2 = new Controller(2, undefined);\r\n    //% fixedInstance whenUsed block=\"player 3\"\r\n    export const player3 = new Controller(3, undefined);\r\n    //% fixedInstance whenUsed block=\"player 4\"\r\n    export const player4 = new Controller(4, undefined);\r\n    //% fixedInstance whenUsed block=\"player 1\"\r\n    export const player1 = new Controller(1, undefined)\r\n}","searchEnginePrompt.ts":"namespace google.prompt { \n    export const _KEYBOARD_CHANGE_EVENT = 7339;\n    export const _KEYBOARD_ENTER_EVENT = 7340;\n    export const _KEYBOARD_CANCEL_EVENT = 7341;\n\n    export interface PromptTheme {\n        colorPrompt: number;\n        colorInput: number;\n        colorInputHighlighted: number;\n        colorInputText: number;\n        colorAlphabet: number;\n        colorCursor: number;\n        colorBackground: number;\n        colorBottomBackground: number;\n        colorBottomText: number;\n    }\n\n    /**\n     * Ask the player for a string value.\n     * @param message The message to display on the text-entry screen\n     * @param answerLength The maximum number of characters the user can enter (1 - 24)\n     * @param useOnScreenKeyboard Force the simulator to use the on-screen keyboard for text entry\n     */\n    //% weight=10 help=game/ask-for-string\n    //% blockId=googlesearchengine\n    //% block=\"ask for string $message || and max length $answerLength use on-screen keyboard $useOnScreenKeyboard\"\n    //% message.shadow=text\n    //% message.defl=\"\"\n    //% answerLength.defl=\"12\"\n    //% answerLength.min=1\n    //% answerLength.max=24\n    //% group=\"Prompt\"\n    export function googleSearchEngine(message: any, answerLength = 12, useOnScreenKeyboard = false) {\n        let p = new Prompt();\n        const result = p.show(console.inspect(message), answerLength, useOnScreenKeyboard);\n        return result;\n    }\n\n\n    //% whenUsed=true\n    const font = image.font8; // FONT8-TODO\n    //% whenUsed=true\n    const PADDING = 4;\n\n    //% whenUsed=true\n    const NUM_LETTERS = 26;\n    //% whenUsed=true\n    const ALPHABET_ROW_LENGTH = 12;\n    //% whenUsed=true\n    const NUM_ROWS = Math.ceil(NUM_LETTERS / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const INPUT_ROWS = 2;\n\n    //% whenUsed=true\n    const CONTENT_WIDTH = screen.width - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_HEIGHT = screen.height - PADDING * 2;\n    //% whenUsed=true\n    const CONTENT_TOP = PADDING;\n\n    // Dimensions of a \"cell\" that contains a letter\n    //% whenUsed=true\n    const CELL_WIDTH = Math.floor(CONTENT_WIDTH / ALPHABET_ROW_LENGTH);\n    //% whenUsed=true\n    const CELL_HEIGHT = CELL_WIDTH;\n    //% whenUsed=true\n    const LETTER_OFFSET_X = Math.floor((CELL_WIDTH - font.charWidth) / 2);\n    //% whenUsed=true\n    const LETTER_OFFSET_Y = Math.floor((CELL_HEIGHT - font.charHeight) / 2);\n    //% whenUsed=true\n    const BLANK_PADDING = 1;\n    //% whenUsed=true\n    const ROW_LEFT = PADDING + Math.floor((CONTENT_WIDTH - (CELL_WIDTH * ALPHABET_ROW_LENGTH)) / 2);\n\n    // Dimensions of the bottom bar\n    //% whenUsed=true\n    const BOTTOM_BAR_ALPHABET_MARGIN = 4;\n    //% whenUsed=true\n    const BOTTOM_BAR_HEIGHT = PADDING + BOTTOM_BAR_ALPHABET_MARGIN + CELL_HEIGHT;\n    //% whenUsed=true\n    const BOTTOM_BAR_BUTTON_WIDTH = PADDING * 2 + font.charWidth * 3;\n    //% whenUsed=true\n    const BOTTOM_BAR_TEXT_Y = (BOTTOM_BAR_HEIGHT - font.charHeight) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_SHIFT_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 3) / 2;\n    //% whenUsed=true\n    const BOTTOM_BAR_CONFIRM_X = (BOTTOM_BAR_BUTTON_WIDTH - font.charWidth * 2) / 2;\n    //% whenUsed=true\n    const CONFIRM_BUTTON_LEFT = screen.width - BOTTOM_BAR_BUTTON_WIDTH;\n\n    // Dimensions of the alphabet area\n    //% whenUsed=true\n    const ALPHABET_HEIGHT = NUM_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_TOP = CONTENT_TOP + CONTENT_HEIGHT - ALPHABET_HEIGHT - BOTTOM_BAR_HEIGHT;\n    //% whenUsed=true\n    const ALPHABET_INPUT_MARGIN = 10;\n\n    // Dimensions of area where text is input\n    //% whenUsed=true\n    const INPUT_HEIGHT = INPUT_ROWS * CELL_HEIGHT;\n    //% whenUsed=true\n    const INPUT_TOP = ALPHABET_TOP - INPUT_HEIGHT - ALPHABET_INPUT_MARGIN;\n\n    //% whenUsed=true\n    const lowerShiftText = \"ABC\";\n    //% whenUsed=true\n    const upperShiftText = \"abc\";\n    //% whenUsed=true\n    const digitsUpper = [\" \", \",\", \".\", \"?\", \"!\", \":\", \";\", \"\\\"\", \"(\", \")\"];\n    //% whenUsed=true\n    const confirmText = \"OK\";\n\n\n    export class Prompt {\n        theme: PromptTheme;\n\n        message: string;\n        answerLength: number;\n        result: string;\n\n        protected confirmPressed: boolean;\n        protected cursorRow: number;\n        protected cursorColumn: number;\n        protected upper: boolean;\n        protected useSystemKeyboard: boolean;\n\n        protected renderable: scene.Renderable;\n        protected selectionStart: number;\n        protected selectionEnd: number;\n\n        protected keyboardRows: number;\n        protected keyboardColumns: number;\n\n        private changeTime = 0;\n\n        constructor(theme?: PromptTheme) {\n            if (theme) {\n                this.theme = theme;\n            }\n            else {\n                this.theme = {\n                    colorPrompt: 1,\n                    colorInput: 3,\n                    colorInputHighlighted: 5,\n                    colorInputText: 1,\n                    colorAlphabet: 1,\n                    colorCursor: 7,\n                    colorBackground: 15,\n                    colorBottomBackground: 3,\n                    colorBottomText: 1,\n                };\n            }\n            this.cursorRow = 0;\n            this.cursorColumn = 0;\n            this.upper = false;\n            this.result = \"\";\n            this.keyboardColumns = ALPHABET_ROW_LENGTH;\n            this.keyboardRows = NUM_ROWS;\n            this.selectionStart = 0;\n            this.selectionEnd = 0;\n        }\n\n        show(message: string, answerLength: number, useOnScreenKeyboard = false) {\n            this.message = message;\n            this.answerLength = answerLength;\n\n            controller._setUserEventsEnabled(false);\n            game.pushScene()\n\n            this.createRenderable();\n            this.confirmPressed = false;\n\n            if (!useOnScreenKeyboard && control.deviceDalVersion() === \"sim\" && helpers._isSystemKeyboardSupported()) {\n                this.useSystemKeyboard = true;\n                helpers._promptForText(this.answerLength, this.numbersOnly());\n                this.selectionEnd = 0;\n                this.selectionStart = 0;\n                control.onEvent(_KEYBOARD_CHANGE_EVENT, 0, () => {\n                    this.result = helpers._getTextPromptString().substr(0, this.answerLength);\n\n                    this.changeTime = game.runtime();\n\n                    this.selectionStart = helpers._getTextPromptSelectionStart();\n                    this.selectionEnd = helpers._getTextPromptSelectionEnd();\n                })\n\n                let cancelled = false;\n                let finished = false;\n\n                control.onEvent(_KEYBOARD_CANCEL_EVENT, 0, () => {\n                    cancelled = true;\n                });\n\n                control.onEvent(_KEYBOARD_ENTER_EVENT, 0, () => {\n                    finished = true;\n                });\n\n                pauseUntil(() => cancelled || finished);\n\n                if (cancelled) {\n                    this.useSystemKeyboard = false;\n                    this.selectionStart = this.result.length;\n                    this.selectionEnd = this.selectionStart;\n                    this.registerHandlers();\n                    pauseUntil(() => this.confirmPressed);\n                }\n            }\n            else {\n                this.useSystemKeyboard = false;\n                this.registerHandlers();\n                pauseUntil(() => this.confirmPressed);\n            }\n\n            game.popScene();\n            controller._setUserEventsEnabled(true);\n\n            return this.result;\n        }\n\n        protected numbersOnly() {\n            return false;\n        }\n\n        protected createRenderable() {\n            if (this.renderable) {\n                this.renderable.destroy();\n            }\n\n            const promptText = new sprites.RenderText(this.message, CONTENT_WIDTH);\n            let systemKeyboardText: sprites.RenderText;\n\n            this.renderable = scene.createRenderable(-1, () => {\n                promptText.draw(screen, (screen.width >> 1) - (promptText.width >> 1), CONTENT_TOP, this.theme.colorPrompt, 0, 2)\n                this.drawInputArea();\n\n                if (!this.useSystemKeyboard) {\n                    this.drawKeyboard();\n                    this.drawBottomBar();\n                    return;\n                }\n\n                if (!systemKeyboardText) {\n                    systemKeyboardText = new sprites.RenderText(helpers._getLocalizedInstructions(), CONTENT_WIDTH);\n                }\n\n                screen.fillRect(0, screen.height - (PADDING << 1) - systemKeyboardText.height, screen.width, screen.height, this.theme.colorBottomBackground);\n                systemKeyboardText.draw(screen, PADDING, screen.height - PADDING - systemKeyboardText.height, this.theme.colorBottomText);\n            });\n        }\n\n        protected drawInputArea() {\n            const answerLeft = ROW_LEFT + Math.floor(\n                ((CELL_WIDTH * ALPHABET_ROW_LENGTH) -\n                    CELL_WIDTH * Math.min(this.answerLength, ALPHABET_ROW_LENGTH)) / 2);\n\n            for (let i = 0; i < this.answerLength; i++) {\n                const col = i % ALPHABET_ROW_LENGTH;\n                const row = Math.floor(i / ALPHABET_ROW_LENGTH);\n\n                if (this.selectionStart !== this.selectionEnd && i >= this.selectionStart && i < this.selectionEnd) {\n                    screen.fillRect(\n                        answerLeft + col * CELL_WIDTH,\n                        INPUT_TOP + row * CELL_HEIGHT,\n                        CELL_WIDTH,\n                        CELL_HEIGHT,\n                        this.theme.colorCursor\n                    );\n                }\n\n                screen.fillRect(\n                    answerLeft + col * CELL_WIDTH + BLANK_PADDING,\n                    INPUT_TOP + row * CELL_HEIGHT + CELL_HEIGHT - 1,\n                    CELL_WIDTH - BLANK_PADDING * 2,\n                    1,\n                    !this.useSystemKeyboard && !this.blink() && i === this.selectionStart ? this.theme.colorInputHighlighted : this.theme.colorInput\n                );\n\n                if (i < this.result.length) {\n                    const char = this.result.charAt(i);\n                    screen.print(\n                        char,\n                        answerLeft + col * CELL_WIDTH + LETTER_OFFSET_X,\n                        INPUT_TOP + row * CELL_HEIGHT + LETTER_OFFSET_Y,\n                        this.theme.colorInputText,\n                        font\n                    );\n                }\n            }\n\n            // draw the blinking text cursor\n            if (this.useSystemKeyboard) {\n                if (this.selectionStart === this.selectionEnd && this.selectionStart < this.answerLength) {\n                    const col = this.selectionStart % ALPHABET_ROW_LENGTH;\n                    const row = Math.floor(this.selectionStart / ALPHABET_ROW_LENGTH);\n                    if (!this.blink()) {\n                        screen.fillRect(\n                            answerLeft + col * CELL_WIDTH,\n                            INPUT_TOP + row * CELL_HEIGHT,\n                            1,\n                            CELL_HEIGHT,\n                            this.theme.colorCursor\n                        );\n                    }\n                }\n            }\n        }\n\n        protected drawKeyboard() {\n            const top = screen.height - BOTTOM_BAR_HEIGHT - this.keyboardRows * CELL_HEIGHT - PADDING;\n            const left = (screen.width >> 1) - ((CELL_WIDTH * this.keyboardColumns) >> 1)\n            for (let j = 0; j < this.keyboardRows * this.keyboardColumns; j++) {\n                const col = j % this.keyboardColumns;\n                const row = Math.idiv(j, this.keyboardColumns);\n\n                if (col === this.cursorColumn && row === this.cursorRow) {\n                    screen.fillRect(\n                        left + col * CELL_WIDTH,\n                        top + row * CELL_HEIGHT,\n                        CELL_WIDTH,\n                        CELL_HEIGHT,\n                        this.theme.colorCursor\n                    )\n                }\n\n                screen.print(\n                    this.getSymbolForIndex(j),\n                    left + col * CELL_WIDTH + LETTER_OFFSET_X,\n                    top + row * CELL_HEIGHT + LETTER_OFFSET_Y,\n                    this.theme.colorAlphabet\n                )\n            }\n        }\n\n        protected drawBottomBar() {\n            this.drawBottomBarBackground();\n            this.drawShift(this.cursorRow === 3 && !(this.cursorColumn & 1));\n            this.drawConfirm(this.cursorRow === 3 && !!(this.cursorColumn & 1));\n        }\n\n        protected drawBottomBarBackground() {\n            screen.fillRect(0, screen.height - BOTTOM_BAR_HEIGHT, screen.width, BOTTOM_BAR_HEIGHT, this.theme.colorBottomBackground);\n        }\n\n        protected drawShift(highlighted: boolean) {\n            if (highlighted) {\n                screen.fillRect(\n                    0,\n                    screen.height - BOTTOM_BAR_HEIGHT,\n                    BOTTOM_BAR_BUTTON_WIDTH,\n                    BOTTOM_BAR_HEIGHT,\n                    this.theme.colorCursor\n                );\n            }\n\n            let shiftText = lowerShiftText;\n            if (this.upper) {\n                shiftText = upperShiftText;\n            }\n            screen.print(\n                shiftText,\n                BOTTOM_BAR_SHIFT_X,\n                screen.height - BOTTOM_BAR_HEIGHT + BOTTOM_BAR_TEXT_Y,\n                this.theme.colorBottomText\n            )\n        }\n\n        protected drawConfirm(highlighted: boolean) {\n            if (highlighted) {\n                screen.fillRect(\n                    CONFIRM_BUTTON_LEFT,\n                    screen.height - BOTTOM_BAR_HEIGHT,\n                    BOTTOM_BAR_BUTTON_WIDTH,\n                    BOTTOM_BAR_HEIGHT,\n                    this.theme.colorCursor\n                );\n            }\n\n            screen.print(\n                confirmText,\n                CONFIRM_BUTTON_LEFT + BOTTOM_BAR_CONFIRM_X,\n                screen.height - BOTTOM_BAR_HEIGHT + BOTTOM_BAR_TEXT_Y,\n                this.theme.colorBottomText\n            )\n        }\n\n        protected getSymbolForIndex(index: number) {\n            return getCharForIndex(index, this.upper);\n        }\n\n        private registerHandlers() {\n            controller.up.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(true);\n            })\n\n            controller.down.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveVertical(false);\n            })\n\n            controller.right.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(true);\n            });\n\n            controller.left.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.moveHorizontal(false);\n            });\n\n            controller.A.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.confirm();\n            });\n\n            controller.B.onEvent(SYSTEM_KEY_DOWN, () => {\n                this.delete();\n            });\n        }\n\n        protected moveVertical(up: boolean) {\n            if (up) {\n                if (this.cursorRow === this.keyboardRows) {\n                    this.cursorRow = this.keyboardRows - 1;\n\n                    if (this.cursorColumn % 2) {\n                        this.cursorColumn = this.keyboardColumns - 1;\n                    }\n                    else {\n                        this.cursorColumn = 0;\n                    }\n                }\n                else {\n                    this.cursorRow = Math.max(0, this.cursorRow - 1);\n                }\n            }\n            else {\n                this.cursorRow = Math.min(this.keyboardRows, this.cursorRow + 1);\n\n                if (this.cursorRow === this.keyboardRows) {\n                    // Go to closest button\n                    this.cursorColumn = this.cursorColumn > 5 ? 1 : 0;\n                }\n            }\n        }\n\n        protected moveHorizontal(right: boolean) {\n            if (right) {\n                this.cursorColumn = (this.cursorColumn + 1) % this.keyboardColumns;\n            }\n            else {\n                this.cursorColumn = (this.cursorColumn + (this.keyboardColumns - 1)) % this.keyboardColumns;\n            }\n        }\n\n        protected confirm() {\n            if (this.cursorRow === 3) {\n                if (this.cursorColumn % 2) {\n                    this.confirmPressed = true;\n                }\n                else {\n                    this.upper = !this.upper;\n                }\n            }\n            else {\n                if (this.selectionStart >= this.answerLength) return;\n\n                const index = this.cursorColumn + this.cursorRow * this.keyboardColumns\n                const letter = getCharForIndex(index, this.upper);\n\n                if (!this.result) {\n                    this.result = letter;\n                }\n                else {\n                    this.result += letter;\n                }\n\n                this.changeTime = game.runtime();\n\n                this.changeInputIndex(1);\n            }\n        }\n\n        protected delete() {\n            if (this.selectionStart <= 0) return;\n\n            this.result = this.result.substr(0, this.result.length - 1);\n            this.changeInputIndex(-1);\n        }\n\n        protected changeInputIndex(delta: number) {\n            this.selectionStart += delta;\n            this.selectionEnd = this.selectionStart;\n        }\n\n        protected blink() {\n            return Math.idiv(game.runtime() - this.changeTime, 500) & 1;\n        }\n    }\n\n    function getCharForIndex(index: number, upper: boolean) {\n        if (index < 26) {\n            return String.fromCharCode(index + (upper ? 65 : 97));\n        }\n        else {\n            if (upper) {\n                return digitsUpper[index - 26];\n            }\n            else {\n                return \"\" + (index - 26);\n            }\n        }\n    }\n}","pxt.json":"{\n    \"name\": \"OneStart\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"ns.ts\",\n        \"controller.ts\",\n        \"control.ts\",\n        \"controllerbutton.ts\",\n        \"controlleroverides.ts\",\n        \"searchEnginePrompt.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[{"id":"34035-71913-45773-30480","timestamp":1754862027790}],"lastSaveTime":1754862177147}